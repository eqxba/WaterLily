#version 450

#extension GL_GOOGLE_include_directive: require

#include "Common.h"
#include "Math.glsl"

#ifndef OCCLUSION_CULLING
    #define OCCLUSION_CULLING 1
#endif

#ifndef FIRST_PASS
    #define FIRST_PASS 1
#endif

layout(local_size_x = PRIMITIVE_CULL_WG_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform Globals
{
    PushConstants globals;
};

layout(set = 0, binding = 0) readonly buffer Primitives 
{
    Primitive primitives[]; 
};

layout(set = 0, binding = 1) readonly buffer Draws 
{
    Draw draws[]; 
};

#if OCCLUSION_CULLING
// TODO: Too much memory for a single bit
layout(set = 0, binding = 2) buffer DrawsVisibility 
{
    uint drawsVisibility[];
};
#endif

layout(set = 0, binding = 3) buffer CommandCount
{
    uint commandCount;
};

#if MESH_PIPELINE
layout(set = 0, binding = 4) writeonly buffer TaskCommands
{
    TaskCommand taskCommands[];
};
#else
layout(set = 0, binding = 4) writeonly buffer IndirectCommands
{
    VkDrawIndexedIndirectCommand indirectCommands[];
};
#endif

#if VISUALIZE_LODS
layout(set = 0, binding = 5) writeonly buffer DrawsDebugData
{
    uint drawsDebugData[];
};
#endif

#if OCCLUSION_CULLING && !FIRST_PASS
layout(set = 1, binding = 0) uniform sampler2D depthPyramid; // TODO: Sort sets
#endif

bool frustumCull(vec3 center, float radius)
{
    bool bCulled = false;

    CullData cullData = globals.cullData;

    // Utilize symmetry: left + right, bottom + top
    bCulled = bCulled || cullData.frustumRightX * abs(center.x) + cullData.frustumRightZ * center.z < -radius;
    bCulled = bCulled || cullData.frustumTopY * abs(center.y) + cullData.frustumTopZ * center.z < -radius;

    bCulled = bCulled || center.z - radius > -cullData.near;
    // Note: infinite far

    return bCulled;
}

uint calculateLodIndex(Primitive primitive, Draw draw, vec3 center, float radius)
{   
    float distanceToSphere = max(length(center) - radius, 0);
    float threshold = distanceToSphere * globals.lodTarget / draw.scale;

    uint lodIndex = 0;

    while (lodIndex < primitive.lodCount - 1 && primitive.lods[lodIndex + 1].error < threshold)
    {
        ++lodIndex;
    }

    return lodIndex;
}

// Each thread processes 1 primitive: selects LOD, does some culling and possibly emits further work
void main()
{
    uint drawIndex = gl_GlobalInvocationID.x;

    if (drawIndex >= globals.drawCount)
    {
        return;
    }
    
    Draw draw = draws[drawIndex];    
    Primitive primitive = primitives[draw.primitiveIndex];

    #if OCCLUSION_CULLING
        bool bVisibleLastFrame = drawsVisibility[drawIndex] == 1;

        #if FIRST_PASS
            if (!bVisibleLastFrame)
            {
                #if !MESH_PIPELINE && !DRAW_INDIRECT_COUNT
                    indirectCommands[drawIndex].instanceCount = 0;
                #endif

                return;
            }
        #endif
    #endif

    vec3 center = rotateQuat(primitive.center, draw.rotation) * draw.scale + draw.position;
    center = (globals.cullData.view * vec4(center, 1.0)).xyz;

    float radius = primitive.radius * draw.scale;

    bool bCulled = frustumCull(center, radius);

    bool bValidLbrt = false;
    vec4 lbrt = vec4(0.0); // NDC (Y up, [-1.0, -1.0] to [1.0, 1.0] range)
    vec2 lbrtExtents = vec2(0.0);

    if (!bCulled) // Contribution culling
    {
        bValidLbrt = sphereNdcExtents(center, radius, globals.projection[0][0], globals.projection[1][1], globals.cullData.near, lbrt);

        if (bValidLbrt)
        {
            lbrtExtents = lbrt.zw - lbrt.xy;
            bCulled = max(lbrtExtents.x, lbrtExtents.y) < CONTRIBUTION_CULL_THRESHOLD;
        }
    }

    #if OCCLUSION_CULLING && !FIRST_PASS
        if (!bCulled && bValidLbrt) // Occlusion culling
        {
            vec4 lbrtUv = vec4(ndcToUv(lbrt.xy), ndcToUv(lbrt.zw));

            // TODO: Support samplerFilterMinmax implementation when we'll have it available ;)
            // We use ceil() here to reduce rectangle to 1x1 texel or smaller, which can cover 2x2 texels (as it's arbitrarily offset)
            // Sampler does nearest filtering and we sample 4 corners to be conservative
            vec2 extentsInTexels = vec2(textureSize(depthPyramid, 0)) * (lbrtUv.zy - lbrtUv.xw); // in UV b > t, so it's y - w
            float mipLevel = ceil(log2((max(extentsInTexels.x, extentsInTexels.y))));
            
            float d0 = textureLod(depthPyramid, lbrtUv.xy, mipLevel).r;
            float d1 = textureLod(depthPyramid, lbrtUv.zy, mipLevel).r;
            float d2 = textureLod(depthPyramid, lbrtUv.xw, mipLevel).r;
            float d3 = textureLod(depthPyramid, lbrtUv.zw, mipLevel).r;

            float minDepth = min(min(d0, d1), min(d2, d3));

            float sphereDepth = -globals.cullData.near / (center.z + radius); // near is positive, but camera looks in -z direction
            bCulled = sphereDepth < minDepth;
        }

        drawsVisibility[drawIndex] = bCulled ? 0 : 1;
    #endif

    #if OCCLUSION_CULLING && !FIRST_PASS
        bool bSkipPrimitive = (bCulled || bVisibleLastFrame);
    #else
        bool bSkipPrimitive = bCulled;
    #endif

    if (bSkipPrimitive) 
    {
        #if !MESH_PIPELINE && !DRAW_INDIRECT_COUNT
            indirectCommands[drawIndex].instanceCount = 0;
        #endif

        return;
    }

    uint lodIndex = globals.bUseLods == 1 ? calculateLodIndex(primitive, draw, center, radius) : 0;
    Lod lod = primitive.lods[lodIndex];

    #if VISUALIZE_LODS
        drawsDebugData[drawIndex] = lodIndex;
    #endif

    #if MESH_PIPELINE
        // TODO: Does this architecture produce enough work for task shader? (i.e. WGs with small meshlet number)
        // Try another approach with compacting and measure perf difference - kinda hard actually to implement
        uint taskCommandCount = (lod.meshletCount + TASK_WG_SIZE - 1) / TASK_WG_SIZE;
        uint commandIndex = atomicAdd(commandCount, taskCommandCount);

        if (commandIndex + taskCommandCount > PRIMITIVE_CULL_MAX_COMMANDS)
        {
            return;
        }
        
        for (uint i = 0; i < taskCommandCount; ++i)
        {
            uint meshletOffset = lod.meshletOffset + i * TASK_WG_SIZE;
            uint meshletCount = min(lod.meshletCount - i * TASK_WG_SIZE, TASK_WG_SIZE);
            
            taskCommands[commandIndex + i].drawIndex = drawIndex;
            taskCommands[commandIndex + i].meshletOffset = meshletOffset;
            taskCommands[commandIndex + i].meshletCount = meshletCount;            
        }
    #else
        #if DRAW_INDIRECT_COUNT
            uint commandIndex = atomicAdd(commandCount, 1);
        #else
            uint commandIndex = drawIndex;
        #endif

        indirectCommands[commandIndex].indexCount = lod.indexCount;
        indirectCommands[commandIndex].instanceCount = 1;    
        indirectCommands[commandIndex].firstIndex = lod.indexOffset;
        indirectCommands[commandIndex].vertexOffset = primitive.vertexOffset;
        indirectCommands[commandIndex].firstInstance = drawIndex;
    #endif
}